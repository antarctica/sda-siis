/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/products': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read the entire set of product definitions, sorted by SIIS product code
     * @description Read the entire set of product definitions, sorted by SIIS product code
     */
    get: operations['product.read_all'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/products/{code}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read one product definition
     * @description Read one product definition
     */
    get: operations['product.read_one'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/products/{code}/granules': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read all granules belonging to same product
     * @description Read all granules belonging to same product
     */
    get: operations['product.read_one_granules'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/granules': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read the entire set of granules, sorted by timestamp
     * @description Read the entire set of granules, sorted by timestamp
     */
    get: operations['granule.read_all'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/granules/{uuid}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read one granule record
     * @description Read one granule record
     */
    get: operations['granule.read_one'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/granules/{uuid}/request_highres': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Issue highres product download request to shore
     * @description Issue highres product download request to shore
     */
    post: operations['granule.request_highres'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/kvs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read the entire set of Key/Value pairs, sorted by key
     * @description Read the entire set of Key/Value pairs, sorted by key
     */
    get: operations['keyvalue.read_all'];
    put?: never;
    post?: never;
    /**
     * Delete all Key/Value pairs
     * @description Delete all Key/Value pairs
     */
    delete: operations['keyvalue.delete_all'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/kvs/{key}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read one Key/Value pair
     * @description Read one Key/Value pair
     */
    get: operations['keyvalue.read_one'];
    /**
     * Update a Key/Value pair
     * @description Update a Key/Value pair
     */
    put: operations['keyvalue.update_one'];
    /**
     * Create a Key/Value pair
     * @description Create a Key/Value pair
     */
    post: operations['keyvalue.create_one'];
    /**
     * Delete one Key/Value pair
     * @description Delete one Key/Value pair
     */
    delete: operations['keyvalue.delete_one'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/routes/convert': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Convert a route between formats for use in external systems
     * @description Converts a route from a source format, such as GeoJSON to a destination format, such as an RTZ.
     */
    post: operations['route.convert'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    product: {
      /** @description Id of the product */
      id?: number;
      /** @description SIIS product code */
      code?: string;
      /** @description product label */
      label?: string;
      /** @description product attribution */
      attribution?: string;
      /** @description Hemisphere of product ('N'/'S'/'') */
      hemisphere?: string;
      /**
       * @description Status of product feed, based on status of granules
       * @enum {string}
       */
      status?: 'offline' | 'online' | 'loading' | 'static' | 'outdated' | 'error';
      /** @description Geoserver layer name */
      gs_layername?: string;
      /** @description Geoserver WMS endpoint - temporary for testing */
      gs_wmsendpoint?: string;
      /** @description Geoserver WFS endpoint - temporary for testing */
      gs_wfsendpoint?: string;
      /** @description Geoserver WMTS endpoint - temporary for testing */
      gs_wmtsendpoint?: string;
      /** @description GeoServer layer style */
      style?: string;
      /**
       * @description Describes the fundamental type of the layer and how it should be handled
       * @enum {string}
       */
      layer_type?: 'raster' | 'vector' | 'imagery_collection';
      formats?: components['schemas']['format'][];
      srss?: components['schemas']['srs'][];
      types?: components['schemas']['type'][];
      /** @description Show product in product list by default */
      show_on_startup?: boolean;
      /**
       * Format: float
       * @description Default render opacity
       */
      default_opacity?: number;
      /** @description Default z-index / layer stacking order for map rendering */
      default_z?: number;
      /** @description Hex color for granule footprint (e.g., "#FF0000") */
      granule_footprint_color?: string;
      /**
       * @description Template URL for IWS viewer Supports placeholders {year}, {month}, {filename}
       * @example http://viewer.example.com/iwsviewer/?image=Data/{year}{month}/{filename}.jp2
       */
      iws_viewer_template?: string;
      /** @description Does product has legend */
      haslegend?: boolean;
      /** @description Holds GeoServer WMS request parameters for legend graphic styling */
      legend_graphic_params?: string;
      /**
       * @description Describes the temporal characteristics of the layer
       * @enum {string}
       */
      temporal_mode?: 'static' | 'single_date' | 'date_range';
      /** @description Array of timestamps available */
      timestamps?: string;
      /** @description Default time filter in hours applied on granules for app rendering */
      default_timeframe?: number;
      /** @description Indicated availability of a corresponding high-resolution granule */
      highres_available?: boolean;
      /** @description product footprint */
      geom_extent?: string;
      /**
       * @deprecated
       * @description Whether overlapping rendering of multiple active granules is allowed or exclusive render of one granule is required
       */
      render_exclusive?: boolean;
      /**
       * @deprecated
       * @description Static background product/layer without granules?
       */
      static?: boolean;
    };
    granule: {
      /** @description Granule UUID */
      id: string;
      /** @description SIIS product code */
      productcode?: string;
      /** @description Filename of product after extraction */
      productname?: string;
      /**
       * Format: date-time
       * @description Timestamp of granule
       */
      timestamp?: string;
      /**
       * @description Status of granule availability on vessel
       * @enum {string}
       */
      status?:
        | 'offline'
        | 'online'
        | 'loading'
        | 'static'
        | 'outdated'
        | 'error'
        | 'hr_requested'
        | 'hr_pending'
        | 'hr_processing'
        | 'hr_online';
      /** @description Downloadable */
      downloadable?: number;
      /** @description Downloaded to local */
      downloaded?: number;
      /** @description Filename of product for download package */
      filename_dl?: string;
      /** @description Download file size */
      size_dl?: number;
      /** @description Zipped product for download */
      zipped?: number;
      /**
       * Format: date-time
       * @description Timestamp of ingestion into shore-side catalogue
       */
      ts_catingest?: string;
      /**
       * Format: date-time
       * @description Timestamp of download request to shore-side
       */
      ts_dlrequest?: string;
      /**
       * Format: date-time
       * @description Timestamp of finished download ship-side
       */
      ts_downloaded?: string;
      /**
       * Format: date-time
       * @description Timestamp of successful ship-side GeoServer ingest
       */
      ts_gsingest?: string;
      /** @description product footprint */
      geom_extent?: string;
      /** @description product footprint in GeoJSON format (MultiPolygon) */
      geojson_extent?: {
        /** @enum {string} */
        type?: 'MultiPolygon';
        coordinates?: number[][][][];
      };
    };
    /** @description Array of WxS types available */
    format: string;
    /** @description GeoServer delivery SRS */
    srs: number;
    /** @description Array of WxS types available */
    type: string;
    products: components['schemas']['product'][];
    granules: components['schemas']['granule'][];
    kv: {
      /** @description Key identifier of KV pair */
      key?: string;
      /** @description Value of KV pair */
      value?: string;
    };
    kvs: components['schemas']['kv'][];
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  'product.read_all': {
    parameters: {
      query?: {
        /** @description maximum number of results to return */
        limit?: number;
        /** @description request hemisphere (N/S) specific products only */
        hemi?: 'N' | 'n' | 'S' | 's';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully read product set operation */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['products'];
        };
      };
    };
  };
  'product.read_one': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description SIIS product code of the product to get */
        code: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully read product from product data operation */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['products'];
        };
      };
    };
  };
  'product.read_one_granules': {
    parameters: {
      query?: {
        /** @description maximum number of results to return */
        limit?: number;
        /** @description maximum age of granule since generation/acquisiton in hours */
        maxage?: number;
        /** @description filters returned granules by acquisition date (YYYY-MM-DD) */
        date?: string;
        /** @description filters returned granules by date range (YYYY-MM-DD/YYYY-MM-DD) */
        date_range?: string;
      };
      header?: never;
      path: {
        /** @description SIIS product code of the granules to get */
        code: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully read granules from granule data operation */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['granules'];
        };
      };
    };
  };
  'granule.read_all': {
    parameters: {
      query?: {
        /** @description maximum number of results to return */
        limit?: number;
        /** @description maximum age of granule since generation/acquisiton in hours */
        maxage?: number;
        /** @description filters returned granules by acquisition date (YYYY-MM-DD) */
        date?: string;
        /** @description filters returned granules by date range (YYYY-MM-DD/YYYY-MM-DD) */
        date_range?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully read granule set operation */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['granules'];
        };
      };
    };
  };
  'granule.read_one': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Granule UUID */
        uuid: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully read granule from granule set opertion */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['granule'];
        };
      };
    };
  };
  'granule.request_highres': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Granule UUID */
        uuid: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Accepted */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Granule not found for UUID */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Method not supported by product */
      405: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'keyvalue.read_all': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Read the entire set of Key/Value pairs, sorted by key */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['kvs'];
        };
      };
    };
  };
  'keyvalue.delete_all': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully deleted all Key-Value pairs */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'keyvalue.read_one': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Key of the KV pair to get */
        key: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully read Key/Value pair */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['kv'];
        };
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'keyvalue.update_one': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Key of the Key/Value pair to update */
        key: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully updated Key/Value pair */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['kv'];
        };
      };
      /** @description Request error */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'keyvalue.create_one': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Key of the Key/Value pair to update */
        key: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['kv'];
      };
    };
    responses: {
      /** @description Successfully created Key/Value pair */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Request error */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'keyvalue.delete_one': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Key of the KV pair to delete */
        key: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully deleted the Key-Value pair */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  'route.convert': {
    parameters: {
      query?: never;
      header: {
        /** @description Accept header - used to specify the desired/destination data format (i.e. what to convert to) */
        accept: 'application/geo+json' | 'application/rtz' | 'application/rtzp';
        /** @description Content Type header - used to specify the source data format (i.e. what to convert from) */
        'content-type': 'application/geo+json' | 'application/rtz' | 'application/rtzp';
      };
      path?: never;
      cookie?: never;
    };
    /** @description Source input */
    requestBody: {
      content: {
        'application/geo+json': unknown;
        'application/rtz': unknown;
        'application/rtzp': unknown;
      };
    };
    responses: {
      /** @description Successfully converted route */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/geo+json': Record<string, never>;
          'application/rtz': string;
          'application/rtzp': string;
        };
      };
    };
  };
}
